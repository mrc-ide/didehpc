% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/queue_didehpc.R
\name{queue_didehpc}
\alias{queue_didehpc}
\alias{queue_didehpc_}
\title{Create a queue object}
\usage{
queue_didehpc(
  context,
  config = didehpc_config(),
  root = NULL,
  initialise = TRUE,
  provision = NULL,
  login = NULL
)
}
\arguments{
\item{context}{A context}

\item{config}{Optional dide configuration information.}

\item{root}{A root directory, not usually needed}

\item{initialise}{Passed through to the base queue. If you set
this to \code{FALSE} you will not be able to submit tasks. By default
if \code{FALSE} this also sets \code{provision} to \code{later} and \code{login} to
\code{FALSE}.}

\item{provision}{A provisioning strategy to use. Options are
\itemize{
\item \code{verylazy} (the default) which installs packages if any declared
package is not present, or if the remote library has already
been provisioned. This is lazier than the \code{lazy} policy and
faster as it avoids fetching package metadata, which may take a
few seconds. If you have manually adjusted your library
(especially by removing packages) you will probably want to use
\code{lazy} or \code{upgrade} to account for dependencies of your declared
packages.
\item \code{lazy}: which tells \code{pkgdepends} to be "lazy" - this prefers to
minimise installation time and does not upgrade packages unless required.
\item \code{upgrade}: which tells \code{pkgdepends} to always try and upgrade
\item \code{later}: don't do anything on creation
\item \code{fake}: don't do anything but mark the queue as being already
provisioned (this option can come in useful if you really don't
want to risk any accidental package installation)
}}

\item{login}{Logical, indicating if we should immediately
login. If \code{TRUE}, then you will be prompted to login
immediately, rather than when a request to the web portal is
made.}
}
\description{
Create a queue object. This is an \link[R6:R6Class]{R6::R6Class} object which you
interact with by calling "methods" which are described below, and
on the help page for \link[queuer:queue_base]{queuer::queue_base}, from which this
derives.
}
\section{Super class}{
\code{\link[queuer:queue_base]{queuer::queue_base}} -> \code{queue_didehpc}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{config}}{Your \code{\link[=didehpc_config]{didehpc_config()}} for this queue.
Do not change this after queue creation as changes may not
take effect as expected.}

\item{\code{client}}{A \link{web_client} object used to
communicate with the web portal. See the help page for its
documentation, but you will typically not need to interact
with this.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{queue_didehpc_$new()}}
\item \href{#method-login}{\code{queue_didehpc_$login()}}
\item \href{#method-cluster_load}{\code{queue_didehpc_$cluster_load()}}
\item \href{#method-reconcile}{\code{queue_didehpc_$reconcile()}}
\item \href{#method-submit}{\code{queue_didehpc_$submit()}}
\item \href{#method-submit_workers}{\code{queue_didehpc_$submit_workers()}}
\item \href{#method-stop_workers}{\code{queue_didehpc_$stop_workers()}}
\item \href{#method-rrq_controller}{\code{queue_didehpc_$rrq_controller()}}
\item \href{#method-unsubmit}{\code{queue_didehpc_$unsubmit()}}
\item \href{#method-dide_id}{\code{queue_didehpc_$dide_id()}}
\item \href{#method-dide_log}{\code{queue_didehpc_$dide_log()}}
\item \href{#method-provision_context}{\code{queue_didehpc_$provision_context()}}
\item \href{#method-install_packages}{\code{queue_didehpc_$install_packages()}}
}
}
\if{html}{
\out{<details ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="enqueue">}\href{../../queuer/html/queue_base.html#method-enqueue}{\code{queuer::queue_base$enqueue()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="enqueue_">}\href{../../queuer/html/queue_base.html#method-enqueue_}{\code{queuer::queue_base$enqueue_()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="enqueue_bulk">}\href{../../queuer/html/queue_base.html#method-enqueue_bulk}{\code{queuer::queue_base$enqueue_bulk()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="initialize_context">}\href{../../queuer/html/queue_base.html#method-initialize_context}{\code{queuer::queue_base$initialize_context()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="lapply">}\href{../../queuer/html/queue_base.html#method-lapply}{\code{queuer::queue_base$lapply()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="mapply">}\href{../../queuer/html/queue_base.html#method-mapply}{\code{queuer::queue_base$mapply()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_bundle_get">}\href{../../queuer/html/queue_base.html#method-task_bundle_get}{\code{queuer::queue_base$task_bundle_get()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_bundle_info">}\href{../../queuer/html/queue_base.html#method-task_bundle_info}{\code{queuer::queue_base$task_bundle_info()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_bundle_list">}\href{../../queuer/html/queue_base.html#method-task_bundle_list}{\code{queuer::queue_base$task_bundle_list()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_delete">}\href{../../queuer/html/queue_base.html#method-task_delete}{\code{queuer::queue_base$task_delete()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_get">}\href{../../queuer/html/queue_base.html#method-task_get}{\code{queuer::queue_base$task_get()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_list">}\href{../../queuer/html/queue_base.html#method-task_list}{\code{queuer::queue_base$task_list()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_result">}\href{../../queuer/html/queue_base.html#method-task_result}{\code{queuer::queue_base$task_result()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_status">}\href{../../queuer/html/queue_base.html#method-task_status}{\code{queuer::queue_base$task_status()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="queuer" data-topic="queue_base" data-id="task_times">}\href{../../queuer/html/queue_base.html#method-task_times}{\code{queuer::queue_base$task_times()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$new(
  context,
  config,
  root,
  initialise,
  provision,
  login,
  client = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{context, config, root, initialise, provision, login}}{See above}

\item{\code{client}}{A \link{web_client} object, primarily useful
for testing the package}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-login"></a>}}
\if{latex}{\out{\hypertarget{method-login}{}}}
\subsection{Method \code{login()}}{
Log onto the web portal. This will be called
automatically at either when creating the object (by default)
or when you make your first request to the portal. However,
you can call this to refresh the session too.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$login(refresh = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{refresh}}{Logical, indicating if we should try
logging on again, even if it looks like we already have.
This will refresh the session, which is typically what you want to do.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cluster_load"></a>}}
\if{latex}{\out{\hypertarget{method-cluster_load}{}}}
\subsection{Method \code{cluster_load()}}{
Report on the overall cluster usage
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$cluster_load(cluster = NULL, nodes = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cluster}}{Cluster to show; if \code{TRUE} show the entire cluster
(via \code{load_overall}), if \code{NULL} defaults to the value
\code{config$cluster}}

\item{\code{nodes}}{Show the individual nodes when printing}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reconcile"></a>}}
\if{latex}{\out{\hypertarget{method-reconcile}{}}}
\subsection{Method \code{reconcile()}}{
Attempt to reconcile any differences in task state
between our database and the HPC queue. This is needed when
tasks have crashed, or something otherwise bad has happened
and you have tasks stuck in \code{PENDING} or \code{RUNNING} that are
clearly not happy. This function does not play well with workers and
you should not use it if using them.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$reconcile(task_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{A vector of tasks to check}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-submit"></a>}}
\if{latex}{\out{\hypertarget{method-submit}{}}}
\subsection{Method \code{submit()}}{
Submit a task to the queue. Ordinarily you do not call
this directly, it is called by the \verb{$enqueue()} method of
\link[queuer:queue_base]{queuer::queue_base} when you create a task. However, you can
use this to resubmit a task that has failed if you think it will
run successfully a second time (e.g., because you cancelled it
the first time around).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$submit(task_ids, names = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{A vector of task identifiers to submit.}

\item{\code{names}}{Optional names for the tasks.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-submit_workers"></a>}}
\if{latex}{\out{\hypertarget{method-submit_workers}{}}}
\subsection{Method \code{submit_workers()}}{
Submit workers to the queue. This only works if
\code{use_rrq} or \code{use_workers} is \code{TRUE} in your configuration.
See \code{vignette("workers")} for more information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$submit_workers(n, timeout = 600, progress = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{The number of workers to submit}

\item{\code{timeout}}{The time to wait, in seconds, for all workers to come
online. An error will be thrown if this time is exceeded.}

\item{\code{progress}}{Logical, indicating if a progress bar should be printed
while waiting for workers.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stop_workers"></a>}}
\if{latex}{\out{\hypertarget{method-stop_workers}{}}}
\subsection{Method \code{stop_workers()}}{
Stop workers running on the cluster. See
\code{vignette("workers")} for more information. By default
workers will timeout after 10 minutes of inactivity.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$stop_workers(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Vector of worker names to try and stop. By
default all workers are stopped.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller}{}}}
\subsection{Method \code{rrq_controller()}}{
Return an \link[rrq:rrq_controller]{rrq::rrq_controller} object, if you have
set \code{use_rrq} or \code{use_workers} in your configuration. This is
a lightweight queue using your workers which is typically much
faster than submitting via \verb{$enqueue()}. See \code{vignette("workers")}
for more information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$rrq_controller()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-unsubmit"></a>}}
\if{latex}{\out{\hypertarget{method-unsubmit}{}}}
\subsection{Method \code{unsubmit()}}{
Unsubmit tasks from the cluster. This removes the tasks
from the queue if they have not been started yet, and stops
them if currently running. It will have no effect if the tasks
are completed (successfully or errored)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$unsubmit(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Vector of task ids to unsubmit.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dide_id"></a>}}
\if{latex}{\out{\hypertarget{method-dide_id}{}}}
\subsection{Method \code{dide_id()}}{
Find the DIDE task id of your task. This is the number
displayed in the web portal.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$dide_id(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Vector of task identifiers to look up}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dide_log"></a>}}
\if{latex}{\out{\hypertarget{method-dide_log}{}}}
\subsection{Method \code{dide_log()}}{
Return the pre-context log of a task. Use this to find
out what has happened to a task that has unexpectedly failed, but
for which \verb{$log()} is uninformative.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$dide_log(task_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{A single task id to check}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-provision_context"></a>}}
\if{latex}{\out{\hypertarget{method-provision_context}{}}}
\subsection{Method \code{provision_context()}}{
Provision your context for running on the cluster.
This sets up the remote set of packages that your tasks will use.
See \code{vignette("packages")} for more information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$provision_context(
  policy = "verylazy",
  dryrun = FALSE,
  quiet = FALSE,
  show_progress = NULL,
  show_log = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{policy}}{The installation policy to use, as interpreted by
\code{pkgdepends::pkg_solution} - so this should be \code{verylazy}/\code{lazy}
(install missing packages but don't upgrade unless needed) or
\code{upgrade} (upgrade packages as possible). In addition you can
also use \code{later} which does nothing, or \code{fake} which pretends
that it ran the provisioning. See \code{vignette("packages")} for
details on these options.}

\item{\code{dryrun}}{Do a dry run installation locally - this just
checks that your requested set of packages is plausible, but does
this without submitting a cluster job so it may be faster.}

\item{\code{quiet}}{Logical, controls printing of informative messages}

\item{\code{show_progress}}{Logical, controls printing of a spinning progress
bar}

\item{\code{show_log}}{Logical, controls printing of the log from the cluster}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-install_packages"></a>}}
\if{latex}{\out{\hypertarget{method-install_packages}{}}}
\subsection{Method \code{install_packages()}}{
Install packages on the cluster. This can be used to
more directly install packages on the cluster than the
\verb{$provision_context} method that you would typically use.
See \code{vignette("packages")} for more information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{queue_didehpc_$install_packages(
  packages,
  repos = NULL,
  policy = "lazy",
  dryrun = FALSE,
  show_progress = NULL,
  show_log = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{packages}}{A character vector of packages to install. These
can be names of CRAN packages or GitHub references etc; see
\code{\link[pkgdepends:pkg_installation_proposal]{pkgdepends::new_pkg_installation_proposal()}} and
\code{vignette("packages")} for more details}

\item{\code{repos}}{A character vector of repositories to use when
installing. A suitable CRAN repo will be added if not detected.}

\item{\code{policy}}{The installation policy to use, as interpreted by
\code{pkgdepends::pkg_solution} - so this should be \code{lazy}
(install missing packages but don't upgrade unless needed) or
\code{upgrade} (upgrade packages as possible). In addition you can
also use \code{later} which does nothing, or \code{fake} which pretends
that it ran the provisioning. See \code{vignette("packages")} for
details on these options.}

\item{\code{dryrun}}{Do a dry run installation locally - this just
checks that your requested set of packages is plausible, but does
this without submitting a cluster job so it may be faster.}

\item{\code{show_progress}}{Logical, controls printing of a spinning progress
bar}

\item{\code{show_log}}{Logical, controls printing of the log from the cluster}
}
\if{html}{\out{</div>}}
}
}
}
